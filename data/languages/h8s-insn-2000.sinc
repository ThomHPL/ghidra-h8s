@include "h8-insn-300.sinc"

# Meanings

RD32:    rd32 is rd32 & bit_hi=0 { export rd32; }
RS32:    rs32 is rs32 & bit_lo=0 { export rs32; }
RS32SET: rs32 is rs32 & bit_lo=1 { export rs32; }

IMM2:     "#"^dit_lohi^":2" is dit_lohi { local c:1 = dit_lohi; export c; }
DISP24:   simm24^":24"      is simm24    { local c:$(ADDRSIZE); extdisp24(c, simm24:3); export c; }
IMM32:    "#"^imm32         is imm32    { local c:4 = imm32; export c; }
DISP32:	  simm32^":32"		is simm32	{ local c:4 = simm32; export c; }

RELPTR16: addr            is simm16 [ addr = inst_next + simm16; ] { export *[ram]:$(ADDRSIZE) addr; }
PTR16D:   "@"^addr^":32"  is imm16 [ addr = $(SEXT_IMM16); ] { export *[ram]:4 addr; }

DEST24:   "@"^addr^":24"  is imm24 [ addr = 0 + imm24; ] { export *[ram]:$(ADDRSIZE) addr; }
PTR24B:   "@"^addr^":8"   is imm24 [ addr = 0 + imm24; ] { export *[ram]:1 addr; }
PTR24W:   "@"^addr^":16"  is imm24 [ addr = 0 + imm24; ] { export *[ram]:2 addr; }
PTR24D:   "@"^addr^":32"  is imm24 [ addr = 0 + imm24; ] { export *[ram]:4 addr; }

RSPTRD:    "@"^rsA^":32"  is rsA & bit_lo=0 { export *:4 rsA; }
RSPTRSD:   "@"^rsA^":32"  is rsA & bit_lo=1 { export *:4 rsA; }
RSPTRINCD: "@"^rsA^"+:32" is rsA & bit_lo=0 { local v = rsA; rsA = rsA + 4; export *:4 v; }
RSPTRDECD: "@-"^rsA^":32" is rsA & bit_lo=1 { rsA = rsA - 4; export *:4 rsA; }


# Instructions

@include "h8s-insn-2000-arith.sinc"
@include "h8s-insn-2000-bit.sinc"
@include "h8s-insn-2000-branch.sinc"
@include "h8s-insn-2000-mem.sinc"

LDC_PTR: RSPTRW is op=0x69; RSPTRW & nib_hi=0 { export RSPTRW; }
LDC_PTR: RSPTRINCW is op=0x6D; RSPTRINCW & nib_hi=0 { export RSPTRINCW; }
LDC_PTR: PTR16W is op16=0x6B00; PTR16W { export PTR16W; }
LDC_PTR: PTR24W is op24=0x6B2000; PTR24W { export PTR24W; }

:ldc.w LDC_PTR, "ccr" is op16=0x0140; LDC_PTR {
	ccr = LDC_PTR:1;
}

:ldc.w "TOFIX""@("^DISP16^","^RSA^")", "ccr" is op24=0x01406F; RSA & nib_hi=0; DISP16 {
	ccr = *(RSA + DISP16);
}

:ldc.w "TOFIX""@("^DISP32^","^RSA^")", "ccr" is op24=0x014078; RSA & nib_hi=0; op16=0x6B20; DISP32 {
	ccr = *(RSA + DISP32);
}

:ldc.w LDC_PTR, "exr" is op16=0x0141; LDC_PTR {
	exr = LDC_PTR:1;
}

:ldc.w "TOFIX""@("^DISP16^","^RSA^")", "exr" is op24=0x01416F; RSA & nib_hi=0; DISP16 {
	exr = *(RSA + DISP16);
}

:ldc.w "TOFIX""@("^DISP32^","^RSA^")", "exr" is op24=0x014178; RSA & nib_hi=0; op16=0x6B20; DISP32 {
	exr = *(RSA + DISP32);
}

:ldc.b IMM8, "exr" is op24=0x014107; IMM8 {
	exr =  IMM8;
}

:ldc.b RD8, "exr" is op=0x03; op_lo=0x1 & RD8 {
	exr = RD8;
}

STC_PTR: RSPTRSW is op=0x69; RSPTRSW & nib_hi=0 { export RSPTRSW; }
STC_PTR: RSPTRDECW is op=0x6D; RSPTRDECW & nib_hi=0 { export RSPTRDECW; }
STC_PTR: PTR16W is op16=0x6B80; PTR16W { export PTR16W; }
STC_PTR: PTR24W is op24=0x6BA000; PTR24W { export PTR24W; }

:stc.b "exr", RD8 is op=0x02; op_lo=0x1 & RD8 {
	RD8 = exr;
}

:stc.w "ccr", STC_PTR is op16=0x0140; STC_PTR {
	STC_PTR = zext(ccr);
}

:stc.w "ccr", "@("^DISP16^","^RSASET^")", is op24=0x01406F; RSASET & nib_hi=0; DISP16 {
	*(RSASET + DISP16) = ccr;
}

:stc.w "ccr", "@("^DISP32^","^RSA^")" is op24=0x014078; RSA & nib_hi=0; op16=0x6BA0; DISP32 {
	*(RSA + DISP32) = ccr;
}

:stc.w "exr", STC_PTR is op16=0x0141; STC_PTR {
	STC_PTR = zext(exr);
}

:stc.w "exr", "@("^DISP16^","^RSASET^")" is op24=0x01416F; RSASET & nib_hi=0; DISP16 {
	*(RSASET + DISP16) = ccr;
}

:stc.w "exr", "@("^DISP32^","^RSA^")" is op24=0x014178; RSA & nib_hi=0; op16=0x6BA0; DISP32 {
	*(RSA + DISP32) = exr;
}

# ldm.l @sp+, (ERn-ERn+1) - Load 2 registers
:ldm.l "@sp+, (er0-er1)" is op16=0x0110; op=0x6D; nib_lo=0x7 & rd32=0x1 {
	er0 = *:4 sp; sp = sp + 4;
	er1 = *:4 sp; sp = sp + 4;
}

:ldm.l "@sp+, (er2-er3)" is op16=0x0110; op=0x6D; nib_lo=0x7 & rd32=0x3 {
	er2 = *:4 sp; sp = sp + 4;
	er3 = *:4 sp; sp = sp + 4;
}

:ldm.l "@sp+, (er4-er5)" is op16=0x0110; op=0x6D; nib_lo=0x7 & rd32=0x5 {
	er4 = *:4 sp; sp = sp + 4;
	er5 = *:4 sp; sp = sp + 4;
}
:ldm.l "@sp+, (er6-er7)" is op16=0x0110; op=0x6D; nib_lo=0x7 & rd32=0x7 {
	er6 = *:4 sp; sp = sp + 4;
	sp = *:4 sp; sp = sp + 4;
}

# ldm.l @sp+, (ERn-ERn+2) - Load 3 registers
:ldm.l "@sp+", "(er0-er2)" is op16=0x0120; op=0x6D; nib_lo=0x7 & rd32=0x2 {
	er0 = *:4 sp; sp = sp + 4;
	er1 = *:4 sp; sp = sp + 4;
	er2 = *:4 sp; sp = sp + 4;
}

:ldm.l "@sp+", "(er4-er6)" is op16=0x0120; op=0x6D; nib_lo=0x7 & rd32=0x6 {
	er4 = *:4 sp; sp = sp + 4;
	er5 = *:4 sp; sp = sp + 4;
	er6 = *:4 sp; sp = sp + 4;
}

# ldm.l @sp+, (ERn-ERn+3) - Load 4 registers
:ldm.l "@sp+", "(er0-er3)" is op16=0x0130; op=0x6D; nib_lo=0x7 & rd32=0x3 {
	er0 = *:4 sp; sp = sp + 4;
	er1 = *:4 sp; sp = sp + 4;
	er2 = *:4 sp; sp = sp + 4;
	er3 = *:4 sp; sp = sp + 4;
}

:ldm.l "@sp+", "(er4-er7)" is op16=0x0130; op=0x6D; nib_lo=0x7 & rd32=0x7 {
	er4 = *:4 sp; sp = sp + 4;
	er5 = *:4 sp; sp = sp + 4;
	er6 = *:4 sp; sp = sp + 4;
	sp = *:4 sp; sp = sp + 4;
}


# stm.l (ERn-ERn+1), @-sp - Store 2 registers
:stm.l "(er0-er1), @-sp" is op16=0x0110; op=0x6D; nib_lo=0xF & rd32=0x0 {
	sp = sp - 4;
	*:4 sp = er1;
	sp = sp - 4;
	*:4 sp = er0;
}

:stm.l "(er2-er3), @-sp" is op16=0x0110; op=0x6D; nib_lo=0xF & rd32=0x2 {
	sp = sp - 4;
	*:4 sp = er3;
	sp = sp - 4;
	*:4 sp = er2;
}

:stm.l "(er4-er5), @-sp" is op16=0x0110; op=0x6D; nib_lo=0xF & rd32=0x4 {
	sp = sp - 4;
	*:4 sp = er5;
	sp = sp - 4;
	*:4 sp = er4;
}

:stm.l "(er6-er7), @-sp" is op16=0x0110; op=0x6D; nib_lo=0xF & rd32=0x6 {
	sp = sp - 4;
	*:4 sp = sp + 4;
	sp = sp - 4;
	*:4 sp = er6;
}

# stm.l (ERn-ERn+2), @-sp - Store 3 registers
:stm.l "(er0-er2), @-sp" is op16=0x0120; op=0x6D; nib_lo=0xF & rd32=0x0 {
	sp = sp - 4;
	*:4 sp = er2;
	sp = sp - 4;
	*:4 sp = er1;
	sp = sp - 4;
	*:4 sp = er0;
}

:stm.l "(er4-er6), @-sp" is op16=0x0120; op=0x6D; nib_lo=0xF & rd32=0x4 {
	sp = sp - 4;
	*:4 sp = er6;
	sp = sp - 4;
	*:4 sp = er5;
	sp = sp - 4;
	*:4 sp = er4;
}

# stm.l (ERn-ERn+3), @-sp - Store 4 registers
:stm.l "(er0-er3), @-sp" is op16=0x0130; op=0x6D; nib_lo=0xF & rd32=0x0 {
	sp = sp - 4;
	*:4 sp = er3;
	sp = sp - 4;
	*:4 sp = er2;
	sp = sp - 4;
	*:4 sp = er1;
	sp = sp - 4;
	*:4 sp = er0;
}

:stm.l "(er4-er7), @-sp" is op16=0x0130; op=0x6D; nib_lo=0xF & rd32=0x4 {
	sp = sp - 4;
	*:4 sp = sp + 4;
	sp = sp - 4;
	*:4 sp = er6;
	sp = sp - 4;
	*:4 sp = er5;
	sp = sp - 4;
	*:4 sp = er4;
}

:mov.l RD32, "@("^DISP24^","^RSA^")" is op24=0x010078; RSA & nib_hi=0; op=0x6B; nib_lo=0xA & RD32; op=0x00; DISP24 {
	local addr = RSA + DISP24;
	instr_movto(*addr, RD32);
}
